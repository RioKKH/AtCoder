#include <iostream>

/**
 * このプログラムは、N枚のカードにかかれた整数A[i] の中から
 * 幾つか選んだとき、その合計が指定の整数Sになる選び方が
 * 存在するかどうかを判定するものです。
 *
 * アプローチとしては、2次元の動的計画法を用います。
 * dp[i][j]を「最初のi枚のカードから幾つか選んで、和がjに
 * なるようにできるかどうか」と定義します。
 *
 * * dp[i][j] がtrueなら、i枚目までのカードを使って、和jを
 * 作る組合せが存在することを意味します。
 *
 * 基本の考え方：
 * 1. dp[0][0]は初期状態としてtrue (何も選ばす和が0になる)とする。
 * 2. 新たなカードi (1-indexed) を考えるときは、以下の2つの選択肢が
 * あります。
 *   - カードiを選ばない: この場合、以前の状態 dp[i-1][j]を引き継ぐ
 *   - カードiを選ぶ: この場合、もしj - a[i]が以前のカードで構成可能で
 *     あれば、dp[i][j]をtrueにする(dp[i-1][j - A[i]]がtrueなら、
 *     カードiを加えることで、jを作れる)。
 *
 * これは2次元の動的計画法で、以下の様な表を作って
 * 問題を解くものです。
 * これはカードが３枚で、それぞれ2, 2, 3が書かれて
 * いた場合に合計が7となるような組合せが存在するかを
 * ２次元の動的計画法を用いて解く場合の例になります。
 *
 *          0 1 2 3 4 5 6 7
 * カード0  o x x x x x x x
 * カード1  o x o x x x x x
 * カード2  o x o x o x x x
 * カード3  o x o o o o x o
 */
int main()
{
    // 変数の宣言
    // N: カードの枚数, S: 目標の和, A: 核カードにかかれた整数 (1-indexed)
    int N, S, A[69];
    // dp[i][j]: 最初i枚のカードを使って和jが作れるかどうか
    // (N <= 60, S<=10000の為、十分なサイズを確保)
    bool dp[69][10009];

    // 入力
    std::cin >> N >> S;
    for (int i = 1; i <= N; i++)
    {
        std::cin >> A[i];
    }

    // 動的計画法 (i = 0)
    dp[0][0] = true;
    for (int i = 1; i <= S; i++)
    {
        // 0枚のカードで1以上の和はつくれないので、falseとする
        dp[0][i] = false;
    }

    // 動的計画法 (i >= 1)
    // i枚目のカードについて、1枚目から順に計算する
    for (int i = 1; i <= N; i++)
    {
        // 各和j(0からSまで) についての可能性を検討する
        for (int j = 0; j <= S; j++)
        {
            // カードiに書かれている整数よりもjが小さい場合、
            // 今回のカードiは加える事が出来ない
            // この場合は、前の状態dp[i-1][j]をそのまま引き継ぐ
            if (j < A[i])
            {
                if (dp[i - 1][j] == true)
                {
                    dp[i][j] = true;
                }
                else
                {
                    dp[i][j] = false;
                }
            }
            // jがA[i]以上の場合は、カードiを使う場合と使わない場合の
            // どちらかで和jを作れるかを判定する
            if (j >= A[i])
            {
                if (dp[i - 1][j] == true || dp[i - 1][j - A[i]] == true)
                {
                    dp[i][j] = true;
                }
                else
                {
                    dp[i][j] = false;
                }
            }
        }
    }

    // 出力
    if (dp[N][S] == true)
    {
        std::cout << "Yes" << std::endl;
    }
    else
    {
        std::cout << "No" << std::endl;
    }
    return 0;
}
